package workload

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"sync/atomic"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/gorilla/websocket"
	"github.com/mattn/go-colorable"
	"github.com/scusemua/workload-driver-react/m/v2/internal/domain"
	"github.com/scusemua/workload-driver-react/m/v2/internal/server/driver"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
)

var (
	ErrMissingMessageId = errors.New("WebSocket message did not contain a top-level \"msg_id\" field")
	ErrMissingOp        = errors.New("WebSocket message did not contain a top-level \"op\" field")
	ErrInvalidOperation = errors.New("Invalid workload-related WebSocket operation requested")

	upgrader = websocket.Upgrader{
		ReadBufferSize:  1024,
		WriteBufferSize: 1024,
	}
)

type websocketRequestHandler func(msgId string, message []byte, ws domain.ConcurrentWebSocket) ([]byte, error)

type WorkloadWebsocketHandler struct {
	logger        *zap.Logger
	sugaredLogger *zap.SugaredLogger

	workloadManager      domain.WorkloadManager                // Provides access to all of the workloads.
	workloadMessageIndex atomic.Int32                          // Monotonically increasing index assigned to each outgoing workload message.
	handlers             map[string]websocketRequestHandler    // A map from operation ID to the associated request handler.
	subscribers          map[string]domain.ConcurrentWebSocket // Websockets that have submitted a workload and thus will want updates for that workload.
	expectedOriginPort   int                                   // The origin port expected for incoming WebSocket connections.
	pushUpdateInterval   time.Duration                         // The interval at which we push updates to the workloads to the frontend.
	workloadStartedChan  chan string                           // Channel of workload IDs. When a workload is started, its ID is submitted to this channel.
}

func NewWorkloadWebsocketHandler(workloadManager domain.WorkloadManager, atom *zap.AtomicLevel) *WorkloadWebsocketHandler {
	handler := &WorkloadWebsocketHandler{
		workloadManager:     workloadManager,
		handlers:            make(map[string]websocketRequestHandler),
		subscribers:         make(map[string]domain.ConcurrentWebSocket),
		workloadStartedChan: make(chan string, 16),
	}

	zapConfig := zap.NewDevelopmentEncoderConfig()
	zapConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder
	core := zapcore.NewCore(zapcore.NewConsoleEncoder(zapConfig), zapcore.AddSync(colorable.NewColorableStdout()), atom)
	logger := zap.New(core, zap.Development())
	if logger == nil {
		panic("failed to create logger for workload driver")
	}

	handler.logger = logger
	handler.sugaredLogger = logger.Sugar()
	handler.setupRequestHandlers()

	return handler
}

func (h *WorkloadWebsocketHandler) setupRequestHandlers() {
	h.handlers["get_workloads"] = h.handleGetWorkloads
	h.handlers["register_workload"] = h.handleRegisterWorkload
	h.handlers["start_workload"] = h.handleStartWorkload
	h.handlers["stop_workload"] = h.handleStopWorkload
	h.handlers["stop_workloads"] = h.handleStopWorkloads
	h.handlers["pause_workload"] = h.handlePauseWorkload
	h.handlers["unpause_workload"] = h.handleUnpauseWorkload
	h.handlers["toggle_debug_logs"] = h.handleToggleDebugLogs
	h.handlers["subscribe"] = h.handleSubscriptionRequest
}

// Upgrade the given HTTP connection to a Websocket connection.
// It is the responsibility of the caller to close the websocket when they're done with it.
func (h *WorkloadWebsocketHandler) upgradeConnectionToWebsocket(c *gin.Context) (domain.ConcurrentWebSocket, error) {
	expectedOriginV1 := fmt.Sprintf("http://127.0.0.1:%d", h.expectedOriginPort)
	expectedOriginV2 := fmt.Sprintf("http://localhost:%d", h.expectedOriginPort)
	h.logger.Debug("Handling websocket origin.", zap.String("request-origin", c.Request.Header.Get("Origin")), zap.String("request-host", c.Request.Host), zap.String("request-uri", c.Request.RequestURI), zap.String("expected-origin-v1", expectedOriginV1), zap.String("expected-origin-v2", expectedOriginV2))

	upgrader.CheckOrigin = func(r *http.Request) bool {
		if r.Header.Get("Origin") == expectedOriginV1 || r.Header.Get("Origin") == expectedOriginV2 {
			return true
		}

		h.sugaredLogger.Errorf("Unexpected origin: %v", r.Header.Get("Origin"))
		return false
	}

	conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
	if err != nil {
		h.logger.Error("Failed to upgrade connection to Websocket.", zap.Error(err))
		return nil, err
	}

	return domain.NewConcurrentWebSocket(conn), nil
}

// Offload a workload-related WebSocket request to the appropriate request handler.
//
// Return the message ID (or an empty string if the message ID could not be extracted), the encoded response payload generated by the handler,
// and any errors encountered either while unpacking the message or while the handler processed the message.
func (h *WorkloadWebsocketHandler) dispatchRequest(message []byte, ws domain.ConcurrentWebSocket) (string, []byte, error) {
	var request map[string]interface{}
	if err := json.Unmarshal(message, &request); err != nil {
		h.logger.Error("Error while unmarshalling data message from workload-related websocket.", zap.Error(err), zap.ByteString("message-bytes", message), zap.String("message-string", string(message)))
		return "", nil, err
	}

	h.sugaredLogger.Debugf("Received workload-related WebSocket message: %v", request)

	var (
		opVal    interface{}
		msgIdVal interface{}
		ok       bool
	)

	if msgIdVal, ok = request["msg_id"]; !ok {
		h.logger.Error("Received unexpected message on websocket. It did not contain an 'op' field.", zap.Binary("message", message))
		return "", nil, ErrMissingMessageId
	}
	msgId := msgIdVal.(string)

	if opVal, ok = request["op"]; !ok {
		h.logger.Error("Received unexpected message on websocket. It did not contain an 'op' field.", zap.String("msg_id", msgId), zap.Binary("message", message))
		return msgId, nil, ErrMissingOp
	}

	opId := opVal.(string)
	handler, ok := h.handlers[opId]
	if !ok {
		h.logger.Error("Invalid workload-related WebSocket operation requested.", zap.String("operation-id", opId))
		return msgId, nil, fmt.Errorf("%w: \"%s\"", ErrInvalidOperation, opId)
	}

	responsePayload, err := handler(msgId, message, ws)
	return msgId, responsePayload, err
}

// Create and return an ErrorMessage wrapping the given error.
// The error parameter must not be nil.
//
// Arguments:
// - err (error): The error for which we're generating an error payload.
// - description(string): Optional text that may provide additional context or information concerning what went wrong. This is to be written by us.
func (h *WorkloadWebsocketHandler) generateErrorPayload(err error, desciption string) *domain.ErrorMessage {
	if err == nil {
		panic("The provided error should not be nil when generating an error payload.")
	}

	return &domain.ErrorMessage{
		ErrorMessage: err.Error(),
		Description:  desciption,
		Valid:        true,
	}
}

// Write a message to the given websocket.
func (h *WorkloadWebsocketHandler) sendMessage(ws domain.ConcurrentWebSocket, payload []byte) error {
	if payload == nil {
		panic("Payload should not be nil when sending a WebSocket message.")
	}

	return ws.WriteMessage(websocket.BinaryMessage, payload)
}

// Given the response and the error returned by a handler, create and return an encoded message to be sent as a response.
//
// If the error is non-nil, then an error message will be created, regardless of the value of the provided response.
// If both the error and the response are nil, then this method will return nil.
func (h *WorkloadWebsocketHandler) getResponsePayload(response []byte, err error) []byte {
	var payload []byte = response // If response is nil, then the payload is nil at this point.
	if err != nil {
		// Error was non-nil, so we'll send back an error message.
		// Overwrite the value of the 'payload' variable with an encoded error message.
		errorMessage := h.generateErrorPayload(err, "")
		payload = errorMessage.Encode()
	}

	return payload
}

// Upgrade the HTTP connection to a WebSocket connection.
// Then, serve requests sent by the remote WebSocket.
func (h *WorkloadWebsocketHandler) serveWorkloadWebsocket(c *gin.Context) error {
	h.logger.Debug("Handling workload-related websocket connection")

	ws, err := h.upgradeConnectionToWebsocket(c)
	if err != nil {
		h.logger.Error("Failed to update HTTP connection to WebSocket connection.", zap.Error(err))
		c.AbortWithError(http.StatusInternalServerError, err)
		return err
	}

	// Used to notify the server-push goroutine that a new workload has been registered.
	doneChan := make(chan struct{})
	go h.serverPushRoutine(doneChan)

	// Process messages until the remote client disconnects or an irrecoverable error occurs.
	for {
		// Read the next message from the WebSocket.
		// ReadMessage is a helper method for getting a reader using NextReader and reading from that reader to a buffer.
		// It will block until a message is received and read.
		_, message, err := ws.ReadMessage()
		if err != nil {
			h.logger.Error("Error while reading message from websocket.", zap.Error(err))
			return err
		}

		// Handle the request.
		msgId, response, err := h.dispatchRequest(message, ws)

		// Create and encode a response.
		payload := h.getResponsePayload(response, err)

		// If the encoded response is nil, then we won't be sending anything back.
		if payload == nil {
			h.logger.Debug("Not sending response for WebSocket message.", zap.String("msg_id", msgId), zap.Any("message", message))
			continue
		}

		// The encoded response is non-nil, so we'll send it back to the remote client.
		if err = h.sendMessage(ws, response); err != nil {
			h.logger.Error("Failed to write WebSocket response.", zap.String("msg_id", msgId), zap.Any("response", response), zap.Error(err))
			c.AbortWithError(http.StatusInternalServerError, err)
			return err
		}
	}
}

// Return the currently-registered workloads.
func (h *WorkloadWebsocketHandler) handleGetWorkloads(msgId string, message []byte, ws domain.ConcurrentWebSocket) ([]byte, error) {
	workloads := h.workloadManager.GetWorkloads()

	responseBuilder := newResponseBuilder(msgId)
	response := responseBuilder.WithModifiedWorkloads(workloads).BuildResponse()
	return response.Encode()
}

// Add a websocket to the subscribers field. This is used for workload-related communication.
func (h *WorkloadWebsocketHandler) handleSubscriptionRequest(msgId string, message []byte, ws domain.ConcurrentWebSocket) ([]byte, error) {
	h.subscribers[ws.RemoteAddr().String()] = ws
	return h.handleGetWorkloads(msgId, message, ws)
}

// Remove a websocket from the subscribers field.
func (h *WorkloadWebsocketHandler) removeSubscription(msgId string, message []byte, ws domain.ConcurrentWebSocket) ([]byte, error) {
	if ws.RemoteAddr() != nil {
		h.logger.Debug("Removing subscription for WebSocket.", zap.String("remote-address", ws.RemoteAddr().String()))
		delete(h.subscribers, ws.RemoteAddr().String())
	}

	return nil, nil
}

// Handle a request to toggle debug logging on/off for a particular workload.
func (h *WorkloadWebsocketHandler) handleToggleDebugLogs(msgId string, message []byte, ws domain.ConcurrentWebSocket) ([]byte, error) {
	req, err := domain.UnmarshalRequestPayload[*domain.ToggleDebugLogsRequest](message)
	if err != nil {
		h.logger.Error("Failed to unmarshal ToggleDebugLogsRequest.", zap.Error(err))
		return nil, err
	}

	modifiedWorkload, err := h.workloadManager.ToggleDebugLogging(req.WorkloadId, req.Enabled)
	if err != nil {
		return nil, err
	}

	// TODO: Consider broadcasting the response?
	responseBuilder := newResponseBuilder(msgId)
	response := responseBuilder.WithModifiedWorkload(modifiedWorkload).BuildResponse()
	return response.Encode()
}

// Handle a request to start a particular workload.
func (h *WorkloadWebsocketHandler) handleStartWorkload(msgId string, message []byte, ws domain.ConcurrentWebSocket) ([]byte, error) {
	req, err := domain.UnmarshalRequestPayload[*domain.StartStopWorkloadRequest](message)
	if err != nil {
		h.logger.Error("Failed to unmarshal StartStopWorkloadRequest.", zap.Error(err))
		return nil, err
	}

	// We're in the 'start workload' handler, but 'StartStopWorkloadRequest' messages can specify an operation ID of either 'start_workload' or 'stop_workload'.
	// So, we're just performing a quick sanity check here to verify that the request did indeed instruct us to start a workload, rather than stop a workload.
	if req.Operation != "start_workload" {
		panic(fmt.Sprintf("Unexpected operation field in StartStopWorkloadRequest: \"%s\"", req.Operation))
	}

	h.logger.Debug("Starting workload.", zap.String("workload-id", req.WorkloadId))

	startedWorkload, err := h.workloadManager.StartWorkload(req.MessageId)
	if err != nil {
		return nil, err
	}

	// Notify the server-push goutine that the workload has started.
	h.workloadStartedChan <- req.WorkloadId

	// TODO: Consider broadcasting the response?
	startedWorkload.UpdateTimeElapsed()
	responseBuilder := newResponseBuilder(msgId)
	response := responseBuilder.WithModifiedWorkload(startedWorkload).BuildResponse()
	return response.Encode()
}

func (h *WorkloadWebsocketHandler) handleStopWorkload(msgId string, message []byte, ws domain.ConcurrentWebSocket) ([]byte, error) {
	req, err := domain.UnmarshalRequestPayload[*domain.StartStopWorkloadRequest](message)
	if err != nil {
		h.logger.Error("Failed to unmarshal StartStopWorkloadRequest.", zap.Error(err))
		return nil, err
	}

	// We're in the 'start workload' handler, but 'StartStopWorkloadRequest' messages can specify an operation ID of either 'start_workload' or 'stop_workload'.
	// So, we're just performing a quick sanity check here to verify that the request did indeed instruct us to start a workload, rather than stop a workload.
	if req.Operation != "stop_workload" {
		panic(fmt.Sprintf("Unexpected operation field in StartStopWorkloadRequest: \"%s\"", req.Operation))
	}

	h.logger.Debug("Stopping workload.", zap.String("workload-id", req.WorkloadId))

	stoppedWorkload, err := h.workloadManager.StartWorkload(req.MessageId)
	if err != nil {
		return nil, err
	}

	// Notify the server-push goutine that the workload has started.
	h.workloadStartedChan <- req.WorkloadId

	// TODO: Consider broadcasting the response?
	stoppedWorkload.UpdateTimeElapsed()
	responseBuilder := newResponseBuilder(msgId)
	response := responseBuilder.WithModifiedWorkload(stoppedWorkload).BuildResponse()
	return response.Encode()
}

// Handle a request to stop a particular workload.
func (h *WorkloadWebsocketHandler) handleStopWorkloads(req *domain.StartStopWorkloadsRequest) {
	req, err := domain.UnmarshalRequestPayload[domain.StartStopWorkloadRequest](message)
	if err != nil {
		h.logger.Error("Failed to unmarshal StartStopWorkloadRequest.", zap.Error(err))
		return nil, err
	}

	if req.Operation != "stop_workloads" {
		panic(fmt.Sprintf("Unexpected operation field in StartStopWorkloadRequest: \"%s\"", req.Operation))
	}

	var updatedWorkloads []domain.Workload = make([]domain.Workload, 0, len(req.WorkloadIDs))

	for _, workloadID := range req.WorkloadIDs {
		h.logger.Debug("Stopping workload.", zap.String("workload-id", workloadID))

		h.driversMutex.RLock()
		workloadDriver, ok := h.workloadDrivers.Get(workloadID)
		h.driversMutex.RUnlock()

		if ok {
			err := workloadDriver.StopWorkload()
			if err != nil {
				h.logger.Error("Error encountered when trying to stop workload.", zap.String("workload-id", workloadID), zap.Error(err))
			} else {
				workload := workloadDriver.GetWorkload()
				// workload.TimeElasped = time.Since(workload.StartTime).String()
				workload.UpdateTimeElapsed()

				h.logger.Debug("Stopped workload.", zap.String("workload-id", workloadID), zap.Any("workload-source", workload.GetWorkloadSource()))
				updatedWorkloads = append(updatedWorkloads, workload)
			}
		} else {
			h.logger.Error("Could not find already-registered workload with the given workload ID.", zap.String("workload-id", workloadID))
		}
	}

	// Lock the workload's driver while we marshal the workload to JSON.
	payload, err := json.Marshal(h.createWorkloadResponseMessage(uuid.NewString(), nil, updatedWorkloads, nil))
	// 	&domain.WorkloadResponse{
	// 	MessageId:         msgId,
	// 	ModifiedWorkloads: updatedWorkloads,
	// }

	if err != nil {
		h.logger.Error("Error while marshalling message payload.", zap.Error(err))
		panic(err)
	}

	h.driversMutex.RLock()
	for _, workload := range updatedWorkloads {
		associatedDriver, _ := h.workloadDrivers.Get(workload.GetId())
		associatedDriver.UnlockDriver()
	}
	h.driversMutex.RUnlock()

	h.broadcastToWorkloadWebsockets(payload)

	h.logger.Debug("Wrote response for STOP_WORKLOADS to frontend.", zap.String("message-id", req.MessageId), zap.Int("requested-num-workloads-stopped", len(req.WorkloadIDs)), zap.Int("actual-num-workloads-stopped", len(updatedWorkloads)))
}

func (h *WorkloadWebsocketHandler) handlePauseWorkload(req *domain.PauseUnpauseWorkloadRequest) {
	panic("Not implemented yet.")
}

func (h *WorkloadWebsocketHandler) handleUnpauseWorkload(req *domain.PauseUnpauseWorkloadRequest) {
	panic("Not implemented yet.")
}

func (h *WorkloadWebsocketHandler) handleRegisterWorkload(request *domain.WorkloadRegistrationRequest, msgId string, websocket domain.ConcurrentWebSocket) {
	workloadDriver := driver.NewWorkloadDriver(h.opts, true, request.TimescaleAdjustmentFactor, websocket, h.atom)

	workload, _ := workloadDriver.RegisterWorkload(request)

	if workload != nil {
		h.workloadsMutex.Lock()
		h.workloads = append(h.workloads, workload)
		h.workloadsMap.Set(workload.GetId(), workload)
		h.workloadsMutex.Unlock()

		h.driversMutex.Lock()
		h.workloadDrivers.Set(workload.GetId(), workloadDriver)
		h.driversMutex.Unlock()

		// Lock the workload's driver while we marshal the workload to JSON.
		workloadDriver.LockDriver()
		payload, err := json.Marshal(h.createWorkloadResponseMessage(msgId, []domain.Workload{workload}, nil, nil))
		// 	&domain.WorkloadResponse{
		// 	MessageId:    msgId,
		// 	NewWorkloads: []domain.Workload{workload},
		// }
		workloadDriver.UnlockDriver()

		if err != nil {
			h.logger.Error("Error while marshalling message payload.", zap.Error(err))
			panic(err)
		}

		h.broadcastToWorkloadWebsockets(payload)

		h.logger.Debug("Wrote response for REGISTER_WORKLOAD to frontend.", zap.String("message-id", msgId), zap.Any("workload-source", workload.GetWorkloadSource()), zap.Any("workload-id", workload.GetId()))
	} else {
		h.logger.Error("Workload registration did not return a Workload object...")
	}
}

// Used to push updates about active workloads to the frontend.
func (h *WorkloadWebsocketHandler) serverPushRoutine(doneChan chan struct{}) {
	// Keep track of the active workloads.
	var (
		activeWorkloads     map[string]domain.Workload = make(map[string]domain.Workload)
		workloadStartedChan <-chan string              = h.workloadStartedChan
	)

	// Add all active workloads to the map.
	for _, workload := range h.workloads {
		if workload.IsRunning() {
			activeWorkloads[workload.GetId()] = workload
		}
	}

	// We'll loop forever, unless the connection is terminated.
	for {
		// If we have any active workloads, then we'll push some updates to the front-end for the active workloads.
		if len(activeWorkloads) > 0 {
			toRemove := make([]string, 0)
			updatedWorkloads := make([]domain.Workload, 0)

			h.driversMutex.RLock()
			// Iterate over all the active workloads.
			for _, workload := range activeWorkloads {
				// If the workload is no longer active, then make a note to remove it after this next update.
				// (We need to include it in the update so the frontend knows it's no longer active.)
				if !workload.IsRunning() {
					toRemove = append(toRemove, workload.GetId())
				}

				associatedDriver, _ := h.workloadDrivers.Get(workload.GetId())
				associatedDriver.LockDriver()

				workload.UpdateTimeElapsed() // Update this field.

				// Lock the workloads' drivers while we marshal the workloads to JSON.
				updatedWorkloads = append(updatedWorkloads, workload)
			}
			h.driversMutex.RUnlock()

			var msgId string = uuid.NewString()
			payload, err := json.Marshal(h.createWorkloadResponseMessage(msgId, nil, updatedWorkloads, nil))
			// 	&domain.WorkloadResponse{
			// 	MessageId:         msgId,
			// 	ModifiedWorkloads: updatedWorkloads,
			// 	MessageIndex:      h.workloadMessageIndex.Add(1),
			// })

			if err != nil {
				h.logger.Error("Error while marshalling message payload.", zap.Error(err))
				panic(err)
			}

			h.driversMutex.RLock()
			for _, workload := range updatedWorkloads {
				associatedDriver, _ := h.workloadDrivers.Get(workload.GetId())
				associatedDriver.UnlockDriver()
			}
			h.driversMutex.RUnlock()

			// Send an update to the frontend.
			h.broadcastToWorkloadWebsockets(payload)

			// TODO: Only push updates if something meaningful has changed.
			h.logger.Debug("Pushed 'Active Workloads' update to frontend.", zap.String("message-id", msgId))

			// Remove workloads that are now inactive from the map.
			for _, id := range toRemove {
				delete(activeWorkloads, id)
			}
		}

		// In case there are a bunch of notifications in the 'workload started channel', consume all of them before breaking out.
		var done bool = false
		for !done {
			// Do stuff.
			select {
			case id := <-workloadStartedChan:
				{
					h.workloadsMutex.RLock()
					// Add the newly-registered workload to the active workloads map.
					activeWorkloads[id], _ = h.workloadsMap.Get(id)
					h.workloadsMutex.RUnlock()
				}
			case <-doneChan:
				{
					return
				}
			default:
				// Do nothing.
				time.Sleep(time.Second * 2)
				done = true // No more notifications right now. We'll process what we have.
			}
		}
	}
}

// Send a binary websocket message to all workload websockets (contained in the 'subscribers' field of the serverImpl struct).
func (h *WorkloadWebsocketHandler) broadcastToWorkloadWebsockets(payload []byte) []error {
	errors := make([]error, 0)

	toRemove := make([]domain.ConcurrentWebSocket, 0)

	for _, conn := range h.subscribers {
		err := conn.WriteMessage(websocket.BinaryMessage, payload)
		if err != nil {
			h.logger.Error("Error while broadcasting websocket message.", zap.Error(err))
			errors = append(errors, err)

			if _, ok := err.(*websocket.CloseError); ok || err == websocket.ErrCloseSent {
				toRemove = append(toRemove, conn)
			}
		}
	}

	for _, conn := range toRemove {
		h.removeSubscription(conn)
	}

	return errors
}

// Pass an empty string for the 'msgId' parameter in order to have the message ID to be automatically generated (as a UUID).
// func (h *WorkloadWebsocketHandler) newResponseBuilder(msgId string) *responseBuilder {
// 	return newResponseBuilder(msgId)
// }

// Create and return a *domain.WorkloadResponse struct.
// We use this function so we can increment the message index field.
// func (h *WorkloadWebsocketHandler) createWorkloadResponseMessage(id string, new []domain.Workload, modified []domain.Workload, deleted []domain.Workload) *domain.WorkloadResponse {
// 	return &domain.WorkloadResponse{
// 		MessageId:         id,
// 		NewWorkloads:      new,
// 		ModifiedWorkloads: modified,
// 		DeletedWorkloads:  deleted,
// 		// MessageIndex:      h.workloadMessageIndex.Add(1),
// 	}
// }
