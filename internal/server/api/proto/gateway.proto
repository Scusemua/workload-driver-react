syntax = "proto3";

import "google/protobuf/timestamp.proto";

option go_package = "github.com/zhangjyr/distributed-notebook/common/proto";
option java_multiple_files = true;
option java_package = "com.github.zhangjyr.distributed-notebook.common.proto";
option java_outer_classname = "GatewayProto";

package gateway;

// gRPC service provided by the ClusterGateway and "used" by the Local Daemons
// (i.e., the Cluster Gateway is the server while the Local Daemons are the clients).
service ClusterGateway {
  // ID returns the cluster gateway id and can be used to test connectivity.
  rpc ID(Void) returns (ProvisionerId) {}

  // RemoveHost removes a local gateway from the cluster.
  rpc RemoveHost(HostId) returns (Void) {}

  // MigrateKernelReplica selects a qualified host and adds a kernel replica to the replica set.
  // Unlike StartKernelReplica, a new replica is added to the replica set and a training task may
  // need to start immediately after replica started, e.g., preempting a training task.
  //
  // The function will simply remove the replica from the kernel without stopping it.
  // The caller should stop the replica after confirmed that the new replica is ready.
  rpc MigrateKernelReplica(MigrationRequest) returns (MigrateKernelResponse) {}

  // Notify the Gateway that a distributed kernel replica has started somewhere.
  rpc NotifyKernelRegistered(KernelRegistrationNotification) returns (KernelRegistrationNotificationResponse) {}

  rpc SmrReady(SmrReadyNotification) returns (Void) {}

  rpc SmrNodeAdded(ReplicaInfo) returns (Void) {}

  // Report that an error occurred within one of the local daemons (or possibly a jupyter kernel).
  rpc Notify(Notification) returns (Void) {}
}

// gRPC service provided by the Cluster Gateway and "used" by the Dashboard
// (i.e., the Cluster Gateway is the server while the Dashboard is the client).
service DistributedCluster {
  // Used for debugging/testing. Causes a Panic.
  rpc InducePanic(Void) returns (Void) {}

  // Used to test notifications.
  rpc SpoofNotifications(Void) returns (Void) {}

  // Used to test connectivity.
  rpc Ping(Void) returns (Pong) {}

  // Used to test connectivity with kernels.
  rpc PingKernel(PingInstruction) returns (Pong) {}

  // Return a list of all of the current kernel IDs.
  rpc ListKernels(Void) returns (ListKernelsResponse) {}

  // Set the maximum number of vGPU resources available on a particular node (identified by the local daemon).
  rpc SetTotalVirtualGPUs(SetVirtualGPUsRequest) returns (VirtualGpuInfo) {}

  // Return the current GPU resource metrics on the node.
  rpc GetClusterActualGpuInfo(Void) returns (ClusterActualGpuInfo) {}

  // Return the current vGPU (or "deflated GPU") resource metrics on the node.
  rpc GetClusterVirtualGpuInfo(Void) returns (ClusterVirtualGpuInfo) {}

  // MigrateKernelReplica selects a qualified host and adds a kernel replica to the replica set.
  // Unlike StartKernelReplica, a new replica is added to the replica set and a training task may
  // need to start immediately after replica started, e.g., preempting a training task.
  //
  // The function will simply remove the replica from the kernel without stopping it.
  // The caller should stop the replica after confirmed that the new replica is ready.
  rpc MigrateKernelReplica(MigrationRequest) returns (MigrateKernelResponse) {}

  // Ensure that the next 'execute_request' for the specified kernel fails.
  // This is to be used exclusively for testing/debugging purposes.
  rpc FailNextExecution(KernelId) returns (Void) {}

  // RegisterDashboard is called by the Cluster Dashboard backend server to both verify that a connection has been
  // established and to obtain any important configuration information, such as the deployment mode (i.e., Docker or
  // Kubernetes), from the Cluster Gateway.
  rpc RegisterDashboard(Void) returns (DashboardRegistrationResponse) {}

  // GetVirtualDockerNodes returns a (pointer to a) GetVirtualDockerNodesResponse struct describing the virtual,
  // simulated nodes currently provisioned within the cluster.
  //
  // When deployed in Docker Swarm mode, our cluster has both "actual" nodes, which correspond to the nodes that
  // Docker Swarm knows about, and virtual nodes that correspond to each local daemon container.
  //
  // In a "real" deployment, there would be one local daemon per Docker Swarm node. But for development and debugging,
  // we may provision many local daemons per Docker Swarm node, where each local daemon manages its own virtual node.
  //
  // If the Cluster is not running in Docker mode, then this will return an error.
  rpc GetVirtualDockerNodes(Void) returns (GetVirtualDockerNodesResponse) {}

  // GetDockerSwarmNodes returns a (pointer to a) GetDockerSwarmNodesResponse struct describing the Docker Swarm
  // nodes that exist within the Docker Swarm cluster.
  //
  // When deployed in Docker Swarm mode, our cluster has both "actual" nodes, which correspond to the nodes that
  // Docker Swarm knows about, and virtual nodes that correspond to each local daemon container.
  //
  // In a "real" deployment, there would be one local daemon per Docker Swarm node. But for development and debugging,
  // we may provision many local daemons per Docker Swarm node, where each local daemon manages its own virtual node.
  //
  // If the Cluster is not running in Docker mode, then this will return an error.
  rpc GetDockerSwarmNodes(Void) returns (GetDockerSwarmNodesResponse) {}

  // AddVirtualDockerNodes provisions a parameterized number of additional nodes within the Docker Swarm cluster.
  rpc AddVirtualDockerNodes(AddVirtualDockerNodesRequest) returns (AddVirtualDockerNodesResponse) {}

  // RemoveVirtualDockerNodes removes a parameterized number of existing nodes from the Docker Swarm cluster.
  rpc RemoveVirtualDockerNodes(RemoveVirtualDockerNodesRequest) returns (RemoveVirtualDockerNodesResponse) {}

  // ModifyVirtualDockerNodes enables the modification of one or more nodes within the Docker Swarm cluster.
  // Modifications include altering the number of GPUs available on the nodes.
  rpc ModifyVirtualDockerNodes(ModifyVirtualDockerNodesRequest) returns (ModifyVirtualDockerNodesResponse) {}
}

// gRPC service provided by the Dashboard and "used" by the Cluster Gateway
// (i.e., the Dashboard is the server while the Cluster Gateway is the client).
service ClusterDashboard {
  rpc SendNotification(Notification) returns (Void) {} // Report to the Dashboard that an error occurred.
}

// DashboardRegistrationResponse encapsulates any important configuration information that is desired by the
// backend server of the Cluster Dashboard.
message DashboardRegistrationResponse {
  // DeploymentMode indicates whether the Cluster is running in Kubernetes mode or Docker mode.
  // Valid options include "local", "docker", and "kubernetes".
  string DeploymentMode = 1;
  // SchedulingMode indicates the scheduling policy that the Cluster Gateway has been configured to use.
  string SchedulingPolicy = 2;
  // NumReplicas refers to the number of replicas that each Jupyter kernel is configured to have.
  int32 NumReplicas = 3;
}

// AddVirtualDockerNodesRequest structs are passed as arguments to the AddVirtualDockerNodes gRPC function.
// An AddVirtualDockerNodesRequest struct encodes the number of nodes to be created as well as any necessary
// configuration that will be used to create/provision the new nodes.
message AddVirtualDockerNodesRequest {
  // RequestId is a unique identifier for this particular AddVirtualDockerNodes operation.
  string requestId = 1;
  // NumNodes specifies the number of virtual nodes to add to the cluster.
  int32 numNodes = 2;
}

// AddVirtualDockerNodesResponse structs are returned by the AddVirtualDockerNodes gRPC function.
// AddVirtualDockerNodesResponse structs describe whether the 'add node(s)' operation was successful.
message AddVirtualDockerNodesResponse {
  // RequestId is the unique identifier that was included in the corresponding AddVirtualDockerNodesRequest struct.
  string requestId = 1;
  // NumNodesCreated describes the number of virtual nodes that were successfully added to the cluster.
  int32 numNodesCreated = 2;
  // NumNodesRequested encodes the number of virtual node that were originally requested to be provisioned.
  int32 numNodesRequested = 3;
}

// RemoveVirtualDockerNodesRequest structs are passed as arguments to the RemoveVirtualDockerNodes gRPC function.
// An RemoveVirtualDockerNodesRequest struct encodes the number of nodes to be removed from the cluster.
message RemoveVirtualDockerNodesRequest {
  // RequestId is a unique identifier for this particular RemoveVirtualDockerNodes operation.
  string requestId = 1;
  // TargetNodes is a slice of strings encoding the node IDs of the nodes that are to be removed.
  repeated string targetNodes = 2;
}

// RemoveVirtualDockerNodesResponse structs are returned by the RemoveVirtualDockerNodes gRPC function.
// RemoveVirtualDockerNodesResponse structs describe whether the 'remove node(s)' operation was successful.
message RemoveVirtualDockerNodesResponse {
  // RequestId is the unique identifier that was included in the corresponding RemoveVirtualDockerNodesRequest struct.
  string requestId = 1;
  // NodesRemoved is a slice of strings encoding the node IDs of the nodes that were successfully removed.
  repeated string nodesRemoved = 3;
  // FailedToRemove is a slice of VirtualDockerNodeRemovalFailure structs encoding information about any nodes
  // whose removal failed, either because the node did not exist or because some other error occurred.
  repeated VirtualDockerNodeRemovalFailure failedToRemove = 4;
}

// VirtualDockerNodeRemovalFailure structs describe a failed node-removal operation.
message VirtualDockerNodeRemovalFailure {
  // RequestId is the unique identifier that was included in the corresponding RemoveVirtualDockerNodesRequest struct.
  string requestId = 1;
  // NodeId is the ID of the node whose removal operation failed.
  string nodeId = 2;
  // Reason encodes the reason for the node-removal failure.
  string reason = 3;
}

// ModifyVirtualDockerNodesRequest structs are passed as arguments to the ModifyVirtualDockerNodes gRPC function.
// An ModifyVirtualDockerNodesRequest struct encodes the properties to be modified for each of the target nodes.
message ModifyVirtualDockerNodesRequest {

}

// ModifyVirtualDockerNodesResponse structs are returned by the ModifyVirtualDockerNodes gRPC function.
// ModifyVirtualDockerNodesResponse structs describe whether the 'modify/update node(s)' operation was successful.
message ModifyVirtualDockerNodesResponse {

}

// GetVirtualDockerNodesResponse is returned by the GetVirtualDockerNodes gRPC function.
// A GetVirtualDockerNodesResponse struct describes all of the virtual nodes within the cluster.
message GetVirtualDockerNodesResponse {
  // Nodes is a slice of VirtualDockerNode structs, where each VirtualDockerNode
  // describes one of the virtual nodes within the cluster.
  repeated VirtualDockerNode nodes = 1;
}

// VirtualDockerNode represents/describes a "virtual" node within the Docker Swarm cluster.
// Docker Swarm clusters have a concept of nodes -- they can span multiple machines or VMs.
// Each Docker Swarm node hosts containers. Virtual nodes correspond to Local Daemons.
// Each Local Daemon manages its own virtual node. If there are multiple local daemon containers
// running on a single Docker Swarm node, then each local daemon manages its own virtual node, so
// there will be multiple virtual nodes on the single Docker Swarm mode.
message VirtualDockerNode {
  // NodeId is the unique identifier of the node.
  string nodeId = 1;
  // Containers is a slice of DockerContainer structs representing the containers running on this VirtualDockerNode.
  repeated DockerContainer containers = 2;
  // SpecCpu is the total number of CPUs on the VirtualDockerNode.
  // This quantity is not impacted by active allocations.
  float specCpu = 3;
  // SpecMemory is the total amount of RAM on the VirtualDockerNode in megabytes (MB).
  // This quantity is not impacted by active allocations.
  float specMemory = 4;
  // SpecGpu is the total number of vGPUs on the VirtualDockerNode.
  // This quantity is not impacted by active allocations.
  float specGpu = 5;
  // AllocatedCpu is the number of vCPUs that is actively/currently allocated on the VirtualDockerNode.
  float allocatedCpu = 6;
  // AllocatedMemory is the amount of memory (in megabytes) that is currently allocated on the VirtualDockerNode.
  float allocatedMemory = 7;
  // AllocatedGpu is the number of vGPUs that is actively/currently allocated on the VirtualDockerNode.
  float allocatedGpu = 8;
    // PendingCpu is the number of vCPUs that is subscribed (but not committed) on the VirtualDockerNode.
    float pendingCpu = 9;
    // PendingMemory is the amount of memory (in megabytes) that is subscribed (but not committed) on the VirtualDockerNode.
    float pendingMemory = 10;
    // PendingGpus is the number of vGPUs that is subscribed (but not committed) on the VirtualDockerNode.
    float pendingGpu = 11;
  // NodeName is the name of the node.
  string nodeName = 12;
  // Address is the IP address of the node.
  string address = 13;
  // CreatedAt is the time that the node was created.
  google.protobuf.Timestamp createdAt = 14;
}

// DockerContainer describes a Docker container.
message DockerContainer {
  string containerName = 1;
  // ContainerStatus describes the [lifecycle state or status] of the Docker container.
  //
  // [lifecycle state or status]: https://docs.docker.com/reference/cli/docker/container/ls/#status
  string containerStatus = 2;
  string containerAge = 3;
  string containerIp = 4;
  bool  valid = 5;
}

// GetDockerSwarmNodesResponse is returned by the GetDockerSwarmNodes gRPC function.
// A GetDockerSwarmNodesResponse struct describes all of the "actual" nodes within the Docker Swarm cluster.
message GetDockerSwarmNodesResponse {
  // Nodes is a slice of DockerSwarmNode structs, where each DockerSwarmNode
  // describes one of the "actual" nodes within the Docker Swarm cluster.
  repeated DockerSwarmNode nodes = 1;
}

// DockerSwarmNode represents/describes an "actual" node within the Docker Swarm cluster.
message DockerSwarmNode {
  string nodeId = 1;
  repeated string containers = 2;
}

message Pong {
  string id = 1;
  bool success = 2;
  string msg = 3; // For adding extra details if the ping fails.
}

message PingInstruction {
  string kernelId = 1; // The kernel to target
  string socketType = 2; // The type of socket to use to issue the "ping" ("control" or "shell")
}

message Notification {
  string title = 1;
  string message = 2;
  int32 notificationType = 3;
  bool panicked = 4;
}

// Used to register the ResourceSpec to be used by a particular kernel.
// If I find a nice way to pass this directly through the usual Jupyter launch-kernel path, then I'll use that instead.
message ResourceSpecRegistration {
  string kernelId = 1; // The ID of the kernel.
  ResourceSpec resourceSpec = 2; // The kernel's resource spec, which should define the resource limits/maximum resources required during the kernel's lifetime.
}

// Mapping from Kubernetes node name to the actual GPU info for that node.
message ClusterActualGpuInfo {
  map<string,GpuInfo> gpuInfo = 1;
}

// Mapping from Kubernetes node name to the virtual GPU info for that node.
message ClusterVirtualGpuInfo {
  map<string,VirtualGpuInfo> gpuInfo = 1;
}

message JupyterKernelReplica {
  string kernelId = 1;
  int32 replicaId = 2;
  string podId = 3;
  string nodeId = 4;
}

message DistributedJupyterKernel {
  string kernelId = 1;
  int32 numReplicas = 2;
  string status = 3;
  string aggregateBusyStatus = 4;
  KernelSpec kernelSpec = 5;
  repeated JupyterKernelReplica replicas = 6;
}

message ListKernelsResponse {
  int32 numKernels = 1;
  repeated DistributedJupyterKernel kernels = 2;
}

message ProvisionerId {
  string id = 1;
}

message HostSpec {
  string ip = 1;
  int32 port = 2;
}

message HostId {
  string id = 1;
  string nodeName = 2; // The name of the Kubernetes node that the Host is running on.
}

// The Jupyter gateway service for host local kernels.
service LocalGateway {
  // SetID sets the local gateway id and return old id for failure tolerance.
  rpc SetID(HostId) returns (HostId) {}

  // StartKernel starts a kernel or kernel replica.
  rpc StartKernel(KernelSpec) returns (KernelConnectionInfo) {}

  // StartKernelReplica starts a kernel replica on the local host.
  rpc StartKernelReplica(KernelReplicaSpec) returns (KernelConnectionInfo) {}

  // GetKernelStatus returns the status of a kernel.
  rpc GetKernelStatus(KernelId) returns (KernelStatus) {}

  // KillKernel kills a kernel.
  rpc KillKernel(KernelId) returns (Void) {}

  // StopKernel stops a kernel gracefully and return immediately.
  rpc StopKernel(KernelId) returns (Void) {}

  // Used to test connectivity with kernels.
  rpc PingKernel(PingInstruction) returns (Pong) {}

  // WaitKernel waits for a kernel to stop and return status.
  rpc WaitKernel(KernelId) returns (KernelStatus) {}

  // SetClose request the gateway to close all kernels and stop.
  rpc SetClose(Void) returns (Void) {}

  // Used to instruct a set of kernel replicas to add a new node to their SMR cluster.
  rpc AddReplica(ReplicaInfoWithAddr) returns (Void) {}

  // Used to instruct a set of kernel replicas to update the peer address of a particular node.
  // This is primarily used during migrations.
  rpc UpdateReplicaAddr(ReplicaInfoWithAddr) returns (Void) {}

  // Used to instruct a specific kernel replica to prepare to be migrated to a new node.
  // This involves writing the contents of the etcd-raft data directory to HDFS so that
  // it can be read back from HDFS by the new replica.
  rpc PrepareToMigrate(ReplicaInfo) returns (PrepareToMigrateResponse) {}

  // Return the current GPU resource metrics on the node.
  rpc GetActualGpuInfo(Void) returns (GpuInfo) {}

  // Return the current vGPU (or "deflated GPU") resource metrics on the node.
  rpc GetVirtualGpuInfo(Void) returns (VirtualGpuInfo) {}

  // Set the maximum number of vGPU resources availabe on the node.
  rpc SetTotalVirtualGPUs(SetVirtualGPUsRequest) returns (VirtualGpuInfo) {}

  // Return the current vGPU allocations on this node.
  rpc GetVirtualGpuAllocations(Void) returns (VirtualGpuAllocations) {}

  // Ensure that the next 'execute_request' for the specified kernel fails.
  // This is to be used exclusively for testing/debugging purposes.
  rpc YieldNextExecution(KernelId) returns (Void) {}
}

// message GetKubernetesNodesResponse {
//   repeated KubernetesNode nodes = 1;
// }
//
// message KubernetesNode {
//   string nodeId = 1;
//   repeated string pods = 2;
//   float allocatableCPU = 3;
//   float allocatableMemory = 4;
//   float allocatableGPUs = 5;
//   float allocatableVGPUs = 6;
//   float allocatedCPU = 7;
//   float allocatedMemory = 8;
//   float allocatedGPUs = 9;
//   float allocatedVGPUs = 10;
// }

message VirtualGpuAllocations {
  map<string,VirtualGpuAllocation> allocations = 1;
}

message VirtualGpuAllocation {
  repeated string deviceIDs = 1;
}

message SetVirtualGPUsRequest {
  int32 value = 1;
  string kubernetesNodeName = 2;
}

// Encapsulates the current vGPU (or "deflated GPU") resource usage on a paritcular node.
message VirtualGpuInfo {
  int32 totalVirtualGPUs = 1;
  int32 allocatedVirtualGPUs = 2;
  int32 freeVirtualGPUs = 3;
}

// Encapsulates the current GPU resource usage on a paritcular node.
message GpuInfo {
  int32 specGPUs= 1; // The total number of GPUs c onfigured/present on this node.
  int32 idleGPUs= 2; // The number of GPUs that are uncommitted and therefore available on this node. This quantity is equal to specGPUs - committedGPUs.
  int32 committedGPUs= 3; // The number of GPUs that are actively committed and allocated to replicas that are scheduled onto this node.
  int32 pendingGPUs= 4; // The sum of the outstanding GPUs of all replicas scheduled onto this node. Pending GPUs are not allocated or committed to a particular replica yet. The time at which resources are actually committed to a replica depends upon the policy being used. In some cases, they're committed immediately. In other cases, they're committed only when the replica is actively training.
  int32 numPendingAllocations= 5; // Number of individual allocations consisting of GPUs that have NOT been fully committed to a kernel.
  int32 numAllocations= 6; // Number of individual allocations such that the GPUs have been committed to a container.
  string gpuSchedulerID = 7; // Unique ID of the gpu scheduler (which is a component of a local daemon) that is reporting these metrics.
  string localDaemonID = 8; // Unique ID of the associated local daemon.
}

// The input for starting a kernel replica.
message KernelReplicaSpec {
  KernelSpec kernel = 1;
  int32 replicaId = 2;
  int32 numReplicas = 3;
  repeated string replicas = 4;
  bool join = 5;
  optional string persistentId = 6;
  int32 dockerModeKernelDebugPort = 7;
}

message ResourceSpec {
  int32 cpu = 1;  // In 1/100 core.
  int32 memory = 2; // In MB.
  int32 gpu = 3; // Number of GPUs.
}

// The kernel id.
message KernelId {
  string id = 1;
  optional bool restart = 2;
  optional string persistentId = 3;
}

// The paramters for migration
message ReplicaInfo {
  string kernelId = 1;
  int32 replicaId = 2;
  string persistentId = 3;
}

message MigrationRequest {
  ReplicaInfo targetReplica = 1;
  optional string targetNodeId = 2;
}

message SmrReadyNotification {
  string kernelId = 1;
  int32 replicaId = 2;
  string persistentId = 3;
  string address = 4;
}

// The replica id.
message ReplicaId {
  int32 id = 1;
}

message PrepareToMigrateResponse {
  int32 id = 1;
  string kernelId = 2;
  string dataDir = 3;
}

message MigrateKernelResponse {
  int32 id = 1;
  string hostname = 2;
}

// Similar to ReplicaInfo, but instead of a persistentId field, this has a hostname field.
message ReplicaInfoWithAddr {
  int32 id = 1;
  string hostname = 2;
  string kernelId = 3;
}

// The kernel spec.
message KernelSpec {
  string id = 1;  // The kernel id.
  string session = 2; // The id of session associated with the kernel manager.
  repeated string argv = 3; // Command line arguments to be passed to the kernel Python process upon starting it.
  string signatureScheme = 4; // The signature scheme to use.
  string key = 5; // The key to use for signing messages.
  ResourceSpec resourceSpec = 6; // Resource requirements of the kernel.
}

// The connection info for a kernel.
message KernelConnectionInfo {
  string ip = 1; // The IP address of the kernel.
  string transport = 2; // The transport protocol to use.
  int32 controlPort = 3; // The port for control messages.
  int32 shellPort = 4; // The port for shell messages.
  int32 stdinPort = 5; // The port for stdin messages.
  int32 hbPort = 6; // The port for heartbeat messages.
  int32 iopubPort = 7; // The port for iopub messages (for the pub socket).
  int32 iosubPort = 8; // The port for iopub messages (for the sub socket).
  int32 ackPort = 9;
  string signatureScheme = 10; // The signature scheme to use.
  string key = 11;  // The key to use for signing messages.
}

// Used as an argument to the Cluster Gateway's NotifyKernelRegistered RPC.
message KernelRegistrationNotification {
  KernelConnectionInfo connectionInfo = 1; // Connection information of the kernel.
  string kernelId = 2; // ID of the Kernel.
  string sessionId = 3; // ID of the associated Session.
  string hostId = 4; // The ID of the LocalDaemonClient associated with this Host. It's basically the ID of the LocalDaemon.
  int32 replicaId = 5; // The SMR replica ID.
  string kernelIp = 6; // The hostname of the kernel itself (not its LocalDaemon).
  string podName = 7; // The name of the Pod hosting the kernel container.
  string nodeName = 8; // Name of the node that the Pod is running on.
  ResourceSpec resourceSpec = 9; // ResourceSpec of the kernel.
  int32 cpu = 10;  // In 1/100 core.
  int32 memory = 11; // In MB.
  int32 gpu = 12; // Number of GPUs.
}

// Returned by the Cluster Gateway for the NotifyKernelRegistered RPC.
message KernelRegistrationNotificationResponse {
  int32 id = 1;
  map<int32,string> replicas = 2;
  int32 smrPort = 3;
  ResourceSpec resourceSpec = 4;
  bool shouldReadDataFromHdfs = 5;
  optional string persistentId = 6;
  // optional string dataDirectory = 6;
  // int32 dockerKernelDebugPort = 7;
}

// The status of a kernel.
message KernelStatus {
  int32 status = 1;
}

message Void{}
